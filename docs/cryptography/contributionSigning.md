# Contribution Signing

In order to verify that contributions listed in the `transcript.json` are actually generated by the addresses listed in the transcript, the contributors MAY sign their contribution with their Ethereum address that they logged in with. And in turn, the secret contributed to the ceremony can be used as a BLS private key which can then sign the participant's Ethereum address or their GitHub name.

## Contribution

### EIP 712

[EIP 712](https://eips.ethereum.org/EIPS/eip-712) defines a standard for messages signed with Ethereum ECDSA keys. This EIP is made available by most JSON RPCs/Web3 Providers under the `eth_signTypedData`/`web3.eth.signTypedData` endpoint. It requires `types`, `primaryType`, `domain`, and `message` combined into a single JSON object. Only the `message` should need to be changed for each contribution, the rest are static fields required by EIP712. These objects are defined as follows:

### `types`

```JSON
"types": {
    "EIP712Domain": [
        {"name":"name","type":"string"},
        {"name":"version","type":"string"},
        {"name":"chainId","type":"uint256"}
    ],
    "contributionPubkey": [
        {"name": "numG1Powers", "type": "uint256"},
        {"name": "numG2Powers", "type": "uint256"},
        {"name": "potPubkey", "type": "bytes"}
    ],
    "PoTPubkeys": [
        { "name": "potPubkeys", "type": "contributionPubkey[]"}
    ]
}
```

### `primaryType`
```JSON
"primaryType": "PoTPubkeys",
```

### `domain`

```JSON
"domain": {
    "name": "Ethereum KZG Ceremony",
    "version": "1.0",
    "chainId": 1
}
```

Note that the array of `contributionPubkey[]` MUST be sorted in increasing order of `numG1Powers` with ties broken by increasing `numG2Powers`. 

### `message`

`message` contains the string-hex (including leading `0x`) encoded PoT-Pubkeys taken from [contribution.md](../contribution/contribution.md). These are `bls.G2Point`s corresponding to the setups for each of the numbers of powers. Thus, an example `message` corresponding with {`1`, `1`, `1`, `1`} (note this is just for demonstration purposes, these specs REQUIRE the secrets to be different) as secrets would be:

```JSON
"message": {
    "potPubkeys": [
        // Note that these contributionPubkeys are sorted by numG1Powers, numG2Powers
        {"numG1Powers": 4096, "numG2Powers": 65, "potPubkey": "0x93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"},
        {"numG1Powers": 8192, "numG2Powers": 65, "potPubkey": "0x93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"},
        {"numG1Powers": 16384, "numG2Powers": 65, "potPubkey": "0x93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"},
        {"numG1Powers": 32768, "numG2Powers": 65, "potPubkey": "0x93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"},
    ]
}
```

### `contribution_to_typed_data_dict()`

The following function is defined to aid in the serialisation of a `Contribution` by building an EIP712 `TypedData` out of a `Contribution`.

```python
def contribution_to_typed_data_str(contribution: Contribution) -> str:
    typed_data_dict = {
        "types": {
            "EIP712Domain": [
                {"name":"name", "type":"string"},
                {"name":"version", "type":"string"},
                {"name":"chainId", "type":"uint256"}
            ],
            "contributionPubkey": [
                {"name": "numG1Powers", "type": "uint256"},
                {"name": "numG2Powers", "type": "uint256"},
                {"name": "potPubkey", "type": "bytes"}
            ],
            "PoTPubkeys": [
                { "name": "potPubkeys", "type": "contributionPubkey[]"}
            ]
        },
        "primaryType": "PoTPubkeys",
        "domain": {
            "name": "Ethereum KZG Ceremony",
            "version": "1.0",
            "chainId": 1
        },
        "message": {
            "potPubkeys": [
                {
                    "numG1Powers": sub_contribution.num_g1_powers,
                    "numG2Powers": sub_contribution.num_g2_powers,
                    "potPubkey": sub_contribution.pot_pubkey  # Note: this should be encoded as per BLS.md
                } for sub_contribution in contribution]
        }
    }
    return json.dumps(typed_data_dict)
```

## Identity

Identities serve two purposes, they are the canonical method for identifying contributors in the `batchTranscript` and they are the "message" that is BLS-signed with the secret to help link the contribution to the contributor.

### Ethereum Address

```python
def encode_ethereum_identity(eth_address: str) -> bytes:
    assert eth_address[:2] == '0x'  # Ethereum Addresses must start with '0x'.
    identity_str = 'eth|' + eth_address.lower()
    return identity_str.encode()
```

### GitHub

```python
def encode_github_identity(github_handle: str) -> bytes:
    # Note that GitHub handles are limited to 39 alpha-numeric chars
    # (Regex: /^[a-z\d](?:[a-z\d]|-(?=[a-z\d])){0,38}$/i) 
    assert github_handle[1] == '@' # GitHub handles must start with '@'.
    identity_str = 'git|' + github_handle.lower()
    return identity_str.encode()
```


